得出了以下实现高质量 equals 方法的诀窍：
1. 使用 == 操作符检查“参数是否为这个对象的引用”。如果是，则返回 true 。这只不过是
一种性能优化，如果比较操作有可能很昂贵，就值得这么做。
2. 使用 instanceof 操作符检查“参数是否为正确的类型”。如果不是，则返回 false 。一般
说来，所谓“正确的类型”是指 equals 方法所在的那个类。有些情况下，是指该类所实现
的某个接口。如果类实现的接口改进了 equals 约定，允许在实现了该接口的类之间进行
比较，那么就使用接口。集合接口（collection interface）
如 Set 、 List 、 Map 和 Map.Entry 具有这样的特性。
3. 把参数转换成正确的类型。因为转换之前进行过 instanceof 测试，所以确保会成功。
4. 对于该类中每个“关键（significant）域，检查参数中的域是否与该对象中对应的域相匹
配”。如果这些测试全部成功，则返回 true ；否则返回 false 。如果第2步中的类型是个
借口，就必须通过接口方法访问参数中的域；如果该类型是个类，也许就能够直接访问
参数中的域，这要取决于它们的可访问性。
对于既不是 float 也不是 double 类型的基本类型域，可以使用 == 操作符进行比较；对
于对象引用域，可以递归地调用 equals 方法；对于 float 域，可以使
用 Float.compare 方法；对于 double 域，则使用 Double.compare 。对
于 float 和 double 域进行特殊的处理是有必要的，因为存在着 Float.NaN 、 -0.0f 以及
类似的 double 常量；详细信息请参考 Float.equals 的文档。对于数组域，则要把以上这
些指导原则应用到每个元素上。如果数组域中的每个元素都很重要，就可以使用发行版
本1.5中新增的其中一个 Arrays.equals 方法。
有些对象引用域包含 null 可能是合法的，所以，为了避免可能导
致 NullPointerException 异常，则使用下面的习惯用法来比较这样的域：
(field == null ? o.field == null : field.equals(o.field))
第8条：覆盖equals时请遵守通用约定
49
如果 field 域和 o.field 通常是相同的对象引用，那么下面的做法就会更快一些：
(field == o.field || (field != null && field.equals(o.field)))
对于有些类，比如前面提到的 CaseInsensitiveString 类，域的比较要比简单的等同性测
试复杂的多。如果是这种情况，可能 会希望保存该域的一个“范式（canonical form）”，
这样 equals 方法就可以根据这些范式进行低开销的精确比较，而不是高开销的非精确比
较。这种方法对于不可变类（见第15条）是最为合适的；如果对象可能发生变化，就必
须使其范式保持最新。
域的比较顺序可能会影响到 equals 方法的性能。为了获得最佳的性能，应该罪行比较最
有可能不一致的域，或者是开销最低的域，最理想的情况是两个条件同时满足的域。你
不应该去比较那些不属于对象逻辑状态的域，例如用于同步操作的 Lock 域。也不需要比
较冗余域（redundant field），因为这些冗余域可以由“关键域”计算获得，但是这样做有
可能提高 equals 方法性能。如果冗余域代表了整个对象的综合描述，比较这个域可以节
省当比较失败时去比较实际数据所需要的开销。例如，假设有一个 Polygon 类，并缓存
了该区域。如果两个多边形有着不同的区域，就没有必要去比较它们的边和至高点。
5. 当你编写完成了 equals 方法之后，应该问自己三个问题：它是不是对称的、传递的、一
致的？并且不要只是自问，还要编写单元测试来检验这些特性！如果答案是否定的，就
要找出原因，再相应地修改 equals 方法的代码。当然， equals 方法也必须满足其他两
个特性（自反性和非空性），但是这两种特性通常会自动满足。